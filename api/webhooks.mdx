---
title: "Webhooks"
description: "Receive real-time notifications when content processing completes or fails."
keywords: ["webhooks", "events", "notifications", "API", "content lifecycle"]
---

ShortKit sends webhook events to your server when key lifecycle events occur. Webhooks allow you to react in real time -- for example, updating your CMS when a video finishes processing, or alerting your team when processing fails.

## Webhook events

| Event | Description |
|-------|-------------|
| `content.ready` | Content has finished processing and is available for playback |
| `content.errored` | Content processing failed |

## Setting up webhooks

Register a webhook endpoint in your ShortKit dashboard or via the API. When you create a webhook, ShortKit generates a signing secret that you use to verify incoming payloads.

### Create a webhook

```bash
curl -X POST https://api.shortkit.dev/v1/webhooks \
  -H "Authorization: Bearer sk_live_your_secret_key" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://yourserver.com/webhooks/shortkit",
    "events": ["content.ready", "content.errored"]
  }'
```

### Response

```json
{
  "data": {
    "id": "whk_abc123",
    "url": "https://yourserver.com/webhooks/shortkit",
    "events": ["content.ready", "content.errored"],
    "secret": "whsec_xyz789abc...",
    "status": "active",
    "createdAt": "2026-02-05T12:00:00Z"
  }
}
```

<Warning>
  The signing secret (`secret`) is only returned once when creating the webhook. Store it securely. If you lose it, you can rotate it to generate a new one.
</Warning>

## Payload format

All webhook deliveries use a consistent envelope:

### Headers

| Header | Description |
|--------|-------------|
| `Content-Type` | `application/json` |
| `X-Shortform-Signature` | HMAC-SHA256 signature for payload verification |
| `X-Shortform-Timestamp` | ISO 8601 timestamp of when the event was sent |
| `X-Shortform-Delivery-ID` | Unique identifier for this delivery attempt |

### content.ready

Sent when content finishes processing and is available for playback in the feed.

```json
{
  "event": "content.ready",
  "data": {
    "id": "sk_content_abc123",
    "title": "Breaking: Weather Alert",
    "status": "ready",
    "duration": 32.5,
    "captionTracks": [
      {
        "language": "en",
        "label": "English",
        "source": "embedded"
      }
    ],
    "customMetadata": {
      "articleUrl": "https://example.com/weather"
    },
    "createdAt": "2026-02-05T11:50:00Z",
    "readyAt": "2026-02-05T11:55:00Z"
  },
  "timestamp": "2026-02-05T11:55:00Z"
}
```

### content.errored

Sent when content processing fails. The `error` object contains details about the failure.

```json
{
  "event": "content.errored",
  "data": {
    "id": "sk_content_def456",
    "title": "Product Demo",
    "status": "error",
    "error": {
      "code": "processing_failed",
      "message": "The uploaded file could not be processed. Ensure the file is a supported video format."
    },
    "createdAt": "2026-02-05T11:50:00Z"
  },
  "timestamp": "2026-02-05T11:53:00Z"
}
```

## Signature verification

Every webhook delivery includes an `X-Shortform-Signature` header containing an HMAC-SHA256 signature. You should verify this signature to confirm the request originated from ShortKit and was not tampered with.

The signature is computed over the raw request body using your webhook signing secret as the key.

```
HMAC-SHA256(webhook_signing_secret, raw_request_body)
```

<Tabs>
  <Tab title="Node.js">
    ```javascript
    const crypto = require('crypto');

    function verifyWebhookSignature(rawBody, signature, secret) {
      const expected = crypto
        .createHmac('sha256', secret)
        .update(rawBody, 'utf8')
        .digest('hex');

      return crypto.timingSafeEqual(
        Buffer.from(signature),
        Buffer.from(expected)
      );
    }

    // Express middleware example
    app.post('/webhooks/shortkit', express.raw({ type: 'application/json' }), (req, res) => {
      const signature = req.headers['x-shortform-signature'];
      const secret = process.env.SHORTKIT_WEBHOOK_SECRET;

      if (!verifyWebhookSignature(req.body, signature, secret)) {
        return res.status(401).send('Invalid signature');
      }

      const event = JSON.parse(req.body);

      switch (event.event) {
        case 'content.ready':
          console.log('Content ready:', event.data.id);
          break;
        case 'content.errored':
          console.log('Content error:', event.data.id, event.data.error);
          break;
      }

      res.status(200).send('OK');
    });
    ```
  </Tab>
  <Tab title="Python">
    ```python
    import hmac
    import hashlib

    def verify_webhook_signature(raw_body: bytes, signature: str, secret: str) -> bool:
        expected = hmac.new(
            secret.encode('utf-8'),
            raw_body,
            hashlib.sha256
        ).hexdigest()
        return hmac.compare_digest(signature, expected)

    # Flask example
    @app.route('/webhooks/shortkit', methods=['POST'])
    def handle_webhook():
        signature = request.headers.get('X-Shortform-Signature')
        secret = os.environ['SHORTKIT_WEBHOOK_SECRET']

        if not verify_webhook_signature(request.data, signature, secret):
            return 'Invalid signature', 401

        event = request.get_json()

        if event['event'] == 'content.ready':
            print(f"Content ready: {event['data']['id']}")
        elif event['event'] == 'content.errored':
            print(f"Content error: {event['data']['id']}")

        return 'OK', 200
    ```
  </Tab>
  <Tab title="Go">
    ```go
    package main

    import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "io"
        "net/http"
        "os"
    )

    func verifyWebhookSignature(body []byte, signature string, secret string) bool {
        mac := hmac.New(sha256.New, []byte(secret))
        mac.Write(body)
        expected := hex.EncodeToString(mac.Sum(nil))
        return hmac.Equal([]byte(signature), []byte(expected))
    }

    func webhookHandler(w http.ResponseWriter, r *http.Request) {
        body, err := io.ReadAll(r.Body)
        if err != nil {
            http.Error(w, "Failed to read body", http.StatusBadRequest)
            return
        }

        signature := r.Header.Get("X-Shortform-Signature")
        secret := os.Getenv("SHORTKIT_WEBHOOK_SECRET")

        if !verifyWebhookSignature(body, signature, secret) {
            http.Error(w, "Invalid signature", http.StatusUnauthorized)
            return
        }

        // Parse and handle the event...
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    }
    ```
  </Tab>
</Tabs>

## Retry policy

If your endpoint does not return a `2xx` response, ShortKit retries the delivery with exponential backoff:

| Attempt | Delay after previous attempt |
|---------|------------------------------|
| 1 | Immediate |
| 2 | 1 minute |
| 3 | 5 minutes |
| 4 | 30 minutes |
| 5 | 2 hours |
| 6 | 24 hours |

After all 6 attempts are exhausted, the delivery is marked as failed. Each retry uses the same `X-Shortform-Delivery-ID`, so you can deduplicate on the receiving end.

<Tip>
  Your endpoint should return a `200` response as quickly as possible. Perform any heavy processing asynchronously after acknowledging receipt.
</Tip>

## Managing webhooks

### List webhooks

```bash
curl https://api.shortkit.dev/v1/webhooks \
  -H "Authorization: Bearer sk_live_your_secret_key"
```

### Update webhook

```bash
curl -X PATCH https://api.shortkit.dev/v1/webhooks/whk_abc123 \
  -H "Authorization: Bearer sk_live_your_secret_key" \
  -H "Content-Type: application/json" \
  -d '{
    "events": ["content.ready"]
  }'
```

### Disable webhook

```bash
curl -X PATCH https://api.shortkit.dev/v1/webhooks/whk_abc123 \
  -H "Authorization: Bearer sk_live_your_secret_key" \
  -H "Content-Type: application/json" \
  -d '{
    "status": "disabled"
  }'
```

### Delete webhook

```bash
curl -X DELETE https://api.shortkit.dev/v1/webhooks/whk_abc123 \
  -H "Authorization: Bearer sk_live_your_secret_key"
```

### Rotate signing secret

Generate a new signing secret. The previous secret remains valid for 1 hour after rotation, giving you time to update your endpoint.

```bash
curl -X POST https://api.shortkit.dev/v1/webhooks/whk_abc123/rotate-secret \
  -H "Authorization: Bearer sk_live_your_secret_key"
```

```json
{
  "data": {
    "id": "whk_abc123",
    "secret": "whsec_newSecret123...",
    "previousSecretExpiresAt": "2026-02-05T13:00:00Z"
  }
}
```

### Send test event

Verify your endpoint is correctly configured by sending a test delivery.

```bash
curl -X POST https://api.shortkit.dev/v1/webhooks/whk_abc123/test \
  -H "Authorization: Bearer sk_live_your_secret_key" \
  -H "Content-Type: application/json" \
  -d '{
    "event": "content.ready"
  }'
```

```json
{
  "data": {
    "deliveryId": "del_test123",
    "status": "success",
    "statusCode": 200,
    "responseTime": 245
  }
}
```

## Best practices

<AccordionGroup>
  <Accordion title="Always verify signatures">
    Never process a webhook payload without verifying the `X-Shortform-Signature` header. This prevents spoofed deliveries.
  </Accordion>
  <Accordion title="Respond quickly, process asynchronously">
    Return a `200` immediately and queue any heavy processing. ShortKit treats slow responses as failures and will retry.
  </Accordion>
  <Accordion title="Handle duplicate deliveries">
    Use the `X-Shortform-Delivery-ID` header to deduplicate. Retries send the same delivery ID, so your handler should be idempotent.
  </Accordion>
  <Accordion title="Monitor delivery failures">
    Check the delivery history for your webhooks to catch endpoint issues early.
  </Accordion>
</AccordionGroup>

## Next steps

<Columns cols={2}>
  <Card title="Content API" icon="video" href="/api/content">
    Upload and manage content.
  </Card>
  <Card title="Events API" icon="bolt" href="/api/events">
    Engagement event ingestion.
  </Card>
</Columns>
