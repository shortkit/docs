---
title: "Architecture"
description: "How ShortKit's components work together: SDK, API, video delivery, and the surfaces you interact with."
keywords: ["architecture", "system design", "technical overview", "SDK architecture", "video delivery"]
---

This page explains how ShortKit's components work together to deliver short-form video experiences. It is intended for engineers evaluating ShortKit or integrating at a deeper level.

## System overview

ShortKit is structured as three layers:

1. **Client SDK** -- Embedded in your app, handles feed UI, video playback, engagement tracking, and remote configuration
2. **ShortKit API** -- A single API at `api.shortkit.dev` that handles feed assembly, content management, configuration, analytics, and identity
3. **Video delivery** -- A global CDN that serves HLS video streams and thumbnails directly to the device

The SDK communicates over exactly two paths: API requests go to `api.shortkit.dev`, and video playback streams directly from the CDN. The SDK never communicates with the transcoding pipeline or any other infrastructure service.

## Two networking paths

The SDK communicates over exactly two networking paths. Understanding this separation is important for firewall rules, proxy configuration, and debugging.

### API path

**SDK** → `api.shortkit.dev` → **ShortKit API**

All feed, config, analytics, and identity requests travel this path. The SDK sends HTTPS requests to the ShortKit API, which processes them and returns JSON responses.

### Video delivery path

**SDK** → **CDN** (HLS manifests and segments, thumbnails)

The SDK receives streaming URLs and thumbnail URLs as part of feed responses. When it is time to play a video, the player fetches HLS manifests and segments directly from the CDN. ShortKit's API servers are not involved in video delivery -- once the feed response provides the URLs, playback is entirely between the device and the CDN.

## API capabilities

The ShortKit API at `api.shortkit.dev` exposes five capabilities:

| Capability | What it does | Endpoint |
|------------|-------------|----------|
| **Feed** | Ranks content, constructs feed responses with streaming and thumbnail URLs | `GET /v1/feed` |
| **Content** | Content metadata, upload orchestration, transcoding lifecycle | `POST /v1/uploads`, `GET /v1/uploads/{id}` |
| **Config** | Remote SDK configuration overlays | `GET /v1/config` |
| **Analytics** | Engagement event ingestion | `POST /v1/events` |
| **Identity** | Anonymous and identified user management, identity merge | `POST /v1/identity/resolve` |

All infrastructure-specific details (video processing asset IDs, CDN token generation, transcoding state) are abstracted behind the API. Your integration only ever references ShortKit content IDs.

## Data flows

### Content upload

1. You call `POST /v1/uploads` with metadata (title, description, tags)
2. ShortKit returns a signed upload URL and a content ID
3. You upload the video file directly to the signed URL
4. ShortKit transcodes the video into an HLS adaptive bitrate ladder (multiple resolutions and bitrates)
5. On completion, a `content.ready` webhook fires and the content status transitions to `ready`
6. Content begins appearing in feed responses

### Feed delivery

1. SDK calls `GET /v1/feed` with a cursor (omitted for the first page)
2. ShortKit assembles the feed: reverse-chronological order, pinned items first, suppressed items excluded, publish/expire windows respected
3. For each content item, the response includes a streaming URL and thumbnail URL
4. Response includes content IDs, streaming URLs, thumbnail URLs, caption tracks, and any custom metadata
5. The SDK renders the feed, assigns players from the pool, and begins prefetching thumbnails

### Engagement tracking

1. The SDK collects events as the user interacts: `playStart`, `watchProgress`, `completion`, `swipe`, and others
2. Events accumulate in memory, each tagged with a timestamp, user ID, session ID, and content ID
3. Every 30 seconds, events are flushed to `POST /v1/events`
4. When the app backgrounds, an immediate flush occurs
5. On next app launch, any unsent events from the previous session are sent first

## Authentication

ShortKit uses API key authentication with two key types and strict environment isolation.

| Key type | Prefix | Transport | Access level |
|----------|--------|-----------|-------------|
| **Publishable** | `pk_live_`, `pk_test_` | `X-API-Key` header | Read-only (feed, config, events) |
| **Secret** | `sk_live_`, `sk_test_` | `Authorization: Bearer` header | Full access (uploads, management) |

**Environment isolation:** Keys prefixed with `live` access production data. Keys prefixed with `test` access a completely separate test environment. There is no crossover.

### User identity

The SDK manages identity in two phases:

1. **Anonymous** -- A device-generated UUID is assigned on first SDK initialization
2. **Identified** -- When your app authenticates a user, call `setUserId()` to merge the anonymous profile into the identified one

Identity resolution merges all engagement data collected during the anonymous phase into the identified user profile.

## Security

- All API communication over TLS 1.2+
- Secret API keys are hashed and never retrievable after initial creation
- Signed CDN URLs with configurable expiry
- Webhook requests signed with HMAC-SHA256 for verification
- Per-organization data isolation

## Next steps

<Columns cols={2}>
  <Card title="SDK overview" icon="mobile" href="/sdk/overview">
    Learn about the SDK capabilities and integration points.
  </Card>
  <Card title="API reference" icon="code" href="/api/introduction">
    Explore the complete API documentation.
  </Card>
</Columns>
